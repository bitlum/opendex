# BOLD-01

## Peer Protocol

Two willing parties may trade directly with each other by first establishing a secure TCP-based communication session between them.

The default TCP listening port is 8885 (XU in ASCII).

**<span style="text-decoration:underline;">Node Identity</span>**

All cryptographic operations are based on the secp256k1 elliptic curve. Each node is expected to maintain a persistent secp256k1 private key which is saved and restored between sessions. It is recommended that the private key can only be reset manually, for example, by deleting a file or database entry. 

**<span style="text-decoration:underline;">Initial Handshake</span>**

The communication session is established by creating a TCP connection and agreeing on ephemeral key material for further encrypted communication, in addition to utilizing the persistent key for authentication. The process of establishing this session is the “handshake” and is carried out between the “initiator” (the node which opened the TCP connection) and the “recipient” (the node which accepted it).

The handshake consists of **each side** sending the SessionInit message, and waiting to receive the SessionAck message back. The first SessionInit** **message is expected to be sent by the initiator node.

The initiator node should know about the recipient node identity in advance.

The recipient node knows about the initiator node identity only after receiving its SessionAck message.

By the end of the handshake, two distinct shared keys are created, one for each side of the communication, to be used for encrypting all messages during the session lifetime. 

**The SessionInit Message (0x00)**

	**string** id = 1

		Message unique identifier, generated by the sender 


    **string** sign = 2


    	secp256k1 signature over sha256 hash of a JSON-serialized msg


    	containing fields 3-7


    **string** peer_pub_key = 3


    	The target node secp256k1 public key (in hex)


    **string** ephemeral_pub_key = 4


        An ephemeral secp256k1 public key (in hex), generated by the sender,


        For ECDH key exchange


    **NodeState** node_state = 5


    	General info regarding the sender current node state


    **string** version = 6


    	OpenDEX client version


    **string** node_pub_key = 7


    	The sender secp256k1 public key (in hex)

	

Once received by the destination node, the message origins can be authenticated as follows:



*    peer_pub_key should match the destination node public key 
*    node_pub_key should match the sender node expected public key (relevant for the initiator node only, which knows the recipient node identity in advance)
*   sign should be a valid secp256k1 signature over sha256 hash of a JSON-serialized msg containing fields 3-7

If valid, the destination node is expected to immediately send the SessionAck message back. Otherwise, it may disconnect.

**The SessionAck Message (0x01)**

	**string** id = 1

		Message unique identifier, generated by the sender 


    **string** req_id = 2


    	Link to the id field from the received SessionInit message


    **string** ephemeral_pub_key = 3


        An ephemeral secp256k1 public key (in hex), generated by the sender,


        For ECDH key exchange

Once the sender generated his ECDH keys, it can calculate the shared key by using ephemeral_pub_key field from the SessionInit message. 

Once the message is received by the destination node (the one which sent the SessionInit message), it can compute the shared key as well.

All future communication from the sender side to the receiver henceforth is expected to use that key to encrypt all data, using **aes-256-cbc** symmetric encryption scheme.

**<span style="text-decoration:underline;">Control Messages</span>**

**The Ping Message (0x04)**

	**string** id = 1

		Message unique identifier, generated by the sender 

In order to allow for the existence of long-lived TCP connections, at times it may be required that both ends keep alive the TCP connection at the application level. Such messages also allow obfuscation of traffic patterns.

The sender of the Ping message expected to receive the Pong message back within a limited time frame. Otherwise, it may disconnect.

**The Pong Message (0x05)**

	**string** id = 1

		Message unique identifier, generated by the sender 

	**string** req_id = 2


    	Link to the id field from the received Ping message

The pong message is to be sent back as a response to the Ping message. It serves as a reply and also serves to keep the connection alive, while explicitly notifying the other end that the receiver is still active. 

**The Disconnecting Message (0x03)**

**string** id = 1

		Message unique identifier, generated by the sender 

	**uint32** reason = 2


    	The reason for the imminent disconnection 

**string** payload = 3

		Optional payload to provide more info regarding the disconnection reason

Inform the connected peer that a disconnection is imminent; If received, the peer should disconnect immediately. When sending, well-behaved hosts give their peers a chance (wait 2 seconds) to disconnect before disconnecting themselves.


<table>
  <tr>
   <td><strong>Reason</strong>
   </td>
   <td><strong>Meaning</strong>
   </td>
  </tr>
  <tr>
   <td>0x01
   </td>
   <td>Response stalling
   </td>
  </tr>
  <tr>
   <td>0x02
   </td>
   <td>Incompatible client protocol version
   </td>
  </tr>
  <tr>
   <td>0x03
   </td>
   <td>Unexpected identity
   </td>
  </tr>
  <tr>
   <td>0x04
   </td>
   <td>Forbidden identity update
   </td>
  </tr>
  <tr>
   <td>0x05
   </td>
   <td>Connected to self
   </td>
  </tr>
  <tr>
   <td>0x06
   </td>
   <td>Not accepting new connections
   </td>
  </tr>
  <tr>
   <td>0x07
   </td>
   <td>Banned
   </td>
  </tr>
  <tr>
   <td>0x08
   </td>
   <td>Already connected
   </td>
  </tr>
  <tr>
   <td>0x09
   </td>
   <td>Shutdown
   </td>
  </tr>
  <tr>
   <td>0x0a
   </td>
   <td>Malformed version
   </td>
  </tr>
  <tr>
   <td>0x0b
   </td>
   <td>Authentication failure: invalid target node
   </td>
  </tr>
  <tr>
   <td>0x0c
   </td>
   <td>Authentication failure: invalid signature
   </td>
  </tr>
  <tr>
   <td>0x0d
   </td>
   <td>Wire protocol error
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">Messages fields custom types</span>**

**The NodeState type**


    **repeated Address** addresses = 3


    	The sender listening TCP addresses for incoming connections


    **repeated string** pairs = 4


        The sender list of trading pair symbols, constructed with the base currency first, followed by a  '/' separator and the quote currency (e.g., [“BTC\LTC”, “BTC\DAI”])


    **string **raiden_address = 5


    	The sender raiden address


    **map<string, string>** lnd_pub_keys = 6


    	The sender list of LND public keys


    **map<string, string>** token_identifiers = 7

		...add description...


    **map<string, LndUris>** lnd_uris = 8

		...add description...

**The Address type**


    **string **host = 1


    **uint32** port = 2
